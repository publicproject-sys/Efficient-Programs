# Eff. Prog. 18.12. Presentations

## 1st Group
### Good Approaches
- Custom order labelling, different heuristics
- Swap with next, best index
- Max adapted very good
- Solve restart optimisation
  - If change, recheck constraints else don’t
### Bad Approaches
- Trail stack
  - Records values before recursive calls
  - Values from before the recursive call can be stored
- Range Bisect
  - Test whole ranges
  - Exit if unsolvable
- Skipping corner constraint
- Iterative labeling
  - Tries to reduce fn calls
  - Uses loop + stack
- Sum tracking
  - Tracks sum of lines to check
### Other Stuff
- 132.5 cycles
- Also showed time

## 2nd Group
### Good Approaches
- Moving variables to global scope
  - R, M, H, o move to global, such that solve doesn’t need to calculate
- Process fastest number first in labelling
- Reduce restarts of solve() (again)
  - If line sum == 1 keep track of change and restart later
- Combine loops in the all-different constraint
### “Meh” Approaches
- Loop unrolling solve()
- Improve restarts in sum()
  - Only one iterator in sum()
- Refactor in sum()
  - Removed reference, just use return? (Unsure)
- Optimise sethi() and setlo() to achieve least branch misses
### Other Stuff
- 46.9 cycles
- Only showed cycles

## 3rd Group
### Good Approaches
- Change labelling to minimal range
- Propagating bounds in solve()
  - Loop until occupation is free and only then restart
- Moving restart and ptr arithmetic
  - Use pointers and restrict to inform that occ and occ2 are not aliased
- Changing sethi() and setlo()
  - Only when equal do restart, otherwise continue
- Improving setting of occupation
  - Pointer arithmetics instead of indices accesses in solve()
- Inlining
  - I think in main()
- Disabling assertions
### Other Stuff
- Showed the whole performance measures, but did not talk about it lol

## 4th Group
- MergeSort Optimisation in Python

